Ти — досвідчений Python-розробник, який спеціалізується на автоматизації e-commerce та створенні гнучких інструментів (tools) для обробки даних.

Твоє завдання — розробити компактний, гнучкий **додаток** (application) з графічним інтерфейсом (GUI) для декодування "сетів" (bundles) із файлів експорту замовлень Shopify. Мета — створити інструмент, який можна легко використовувати для різних магазинів, просто завантажуючи різні файли "джерела правди".

**Вимоги до Технологій:**
* **GUI:** Використовуй вбудовану бібліотеку **`tkinter`** для створення простого та зрозумілого графічного інтерфейсу.
* **Обробка даних:** Використовуй **`pandas`** для читання, маніпуляції та збереження даних.
* **Весь проект писати англійською**
* **Функціонал повинен тестуватись юніт тестами**
---

**Компоненти та Логіка Додатку (Application Flow):**

Додаток повинен мати чіткий інтерфейс, що складається з трьох основних секцій:

**1. Секція 1: Завантаження "Мастер-Файлів"**

* **GUI:** Повинна бути кнопка "Завантажити Мастер-Файл (.xlsx)".
* **Логіка:**
    * Користувач вибирає **один `.xlsx` файл** ("HERBAR_TRUTH_FILE.xlsx" або аналогічний).
    * Додаток (використовуючи `pandas.ExcelFile` або `pd.read_excel` з `sheet_name=None`) повинен автоматично прочитати **два аркуші (sheets)** з цього файлу:
        * **Аркуш 'PRODUCTS'**:
            * Очікувані колонки: `Products_Name`, `SKU`, `Quantity_Product`.
            * Додаток повинен створити "Мапу Продуктів" (словник `dict`).
            * *Ключ*: `SKU`.
            * *Значення*: Словник `{'name': Products_Name, 'physical_qty': Quantity_Product}`.
            * *Важливо:* Оброби дублікати `SKU`, взявши *перший* запис: `products_df.drop_duplicates(subset=['SKU'], keep='first')`.
        * **Аркуш 'SETS'**:
            * Очікувані колонки: `SET_Name`, `SET_SKU`, `SKUs_in_SET`.
            * Додаток повинен створити "Мапу Сетів" (словник `dict`).
            * *Ключ*: `SET_SKU`.
            * *Значення*: *Список* (list) усіх `SKUs_in_SET`, які належать до цього `SET_SKU` (використовуй `groupby`).
    * Ці дві "мапи" повинні зберігатися в пам'яті додатку для подальшої обробки.
    * В інтерфейсі має з'явитися повідомлення: "Мастер-файл успішно завантажено".

**2. Секція 2: Завантаження та Редагування Замовлень**

* **GUI:**
    1.  Кнопка "Завантажити Експорт Замовлень (.csv)".
    2.  Секція "Додати продукт до замовлення" з полями:
        * Поле вводу: "ID Замовлення" (напр., `#76360`)
        * Поле вводу: "SKU"
        * Поле вводу: "Кількість"
        * Кнопка "Додати"
* **Логіка (Завантаження):**
    * Користувач вибирає файл експорту замовлень (напр., `orders_export.csv`).
    * Додаток завантажує цей CSV у `pandas.DataFrame` і зберігає його в пам'яті.
    * В інтерфейсі з'являється повідомлення: "Файл замовлень завантажено (X рядків)".
* **Логіка (Ручне Додавання):**
    * Коли користувач заповнює поля і натискає "Додати":
    * Додаток повинен знайти *перший-ліпший* рядок у DataFrame замовлень, де колонка `Name` (ID замовлення) відповідає введеному "ID Замовлення".
    * Якщо рядок **не знайдено**, вивести помилку: " Помилка: ID замовлення не знайдено".
    * Якщо рядок **знайдено**:
        1.  Створити **повну копію** цього рядка (напр., `new_row = existing_row.copy()`).
        2.  Оновити `new_row`, використовуючи дані з полів вводу:
            * `new_row['Lineitem sku'] =` (введений SKU)
            * `new_row['Lineitem quantity'] =` (введена Кількість)
        3.  Автоматично знайти назву продукту в "Мапі Продуктів":
            * `product_details = product_map.get(введений SKU)`
            * `new_row['Lineitem name'] = product_details['name']` (якщо знайдено) або `введений SKU` (якщо не знайдено).
        4.  Встановити фінансові показники для цього рядка на 0, щоб уникнути дублювання:
            * `new_row['Lineitem price'] = 0`
            * `new_row['Lineitem discount'] = 0` (або `Discount Amount`)
        5.  Додати цей `new_row` до основного DataFrame замовлень, що зберігається в пам'яті.
        6.  Вивести повідомлення: "Додано [SKU] (К-ть: X) до замовлення [ID]".

**3. Секція 3: Обробка та Збереження**

* **GUI:** Велика кнопка "Обробити та Зберегти Як...".
* **Логіка:**
    1.  Перевірити, чи завантажені "Мастер-файл" та "Файл замовлень". Якщо ні — вивести помилку.
    2.  Ініціалізувати порожній список `processed_rows`.
    3.  Ітерувати по кожному рядку (`order_row`) з DataFrame замовлень, що в пам'яті.
    4.  Отримати `sku = order_row['Lineitem sku']`.
    5.  **Якщо `sku` є в "Мапі Сетів" (`set_map.get(sku)`)**:
        * Це сет. *Не додавати* `order_row` у `processed_rows`.
        * Отримати `order_quantity = int(order_row['Lineitem quantity'])`.
        * Отримати `order_price = order_row['Lineitem price']`.
        * Отримати список компонентів: `component_skus = set_map[sku]`.
        * Ітерувати по кожному `component_sku` у списку `component_skus`:
            * Створити `new_row = order_row.to_dict()`.
            * Отримати `component_details` з "Мапи Продуктів" (`product_map.get(component_sku)`).
            * Якщо `component_details` знайдено:
                * `new_row['Lineitem name'] = component_details['name']`
                * `physical_qty = int(component_details['physical_qty'])`
            * Якщо ні (SKU компонента немає в "Мапі Продуктів"):
                * `new_row['Lineitem name'] = component_sku` (використовувати SKU як запасний варіант)
                * `physical_qty = 1`
            * Оновити `new_row`:
                * `new_row['Lineitem sku'] = component_sku`
                * `new_row['Lineitem quantity'] = order_quantity * physical_qty`
            * **Правило Ціни:** Встановити `order_price` *лише* на перший компонент сету.
                * `new_row['Lineitem price'] = order_price` (якщо це перший компонент)
                * `new_row['Lineitem price'] = 0` (для всіх наступних компонентів)
            * Додати `new_row` до `processed_rows`.
    6.  **Якщо `sku` НЕМАЄ в "Мапі Сетів"**:
        * Це звичайний продукт (або вручну доданий).
        * Додати `order_row.to_dict()` до `processed_rows` без змін.
    7.  Після завершення циклу, створити фінальний DataFrame: `output_df = pd.DataFrame(processed_rows)`.
    8.  Відкрити діалогове вікно "Зберегти Як..." (`tkinter.filedialog.asksaveasfilename`) і запропонувати користувачу зберегти `output_df` як новий `.csv` файл (`output_df.to_csv(..., index=False)`).
    9.  Вивести фінальне повідомлення: "Успішно! Файл збережено."

**Формат Відповіді:**
Надай повний та готовий Python-додаток в репозиторії, який реалізує весь описаний функціонал з використанням `tkinter` та `pandas`. Код повинен бути добре коментований.
